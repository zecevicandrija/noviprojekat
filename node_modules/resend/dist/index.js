"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Resend: () => Resend
});
module.exports = __toCommonJS(index_exports);

// package.json
var version = "6.3.0";

// src/common/utils/build-pagination-query.ts
function buildPaginationQuery(options) {
  const searchParams = new URLSearchParams();
  if (options.limit !== void 0) {
    searchParams.set("limit", options.limit.toString());
  }
  if ("after" in options && options.after !== void 0) {
    searchParams.set("after", options.after);
  }
  if ("before" in options && options.before !== void 0) {
    searchParams.set("before", options.before);
  }
  return searchParams.toString();
}

// src/api-keys/api-keys.ts
var ApiKeys = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    const data = await this.resend.post(
      "/api-keys",
      payload,
      options
    );
    return data;
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/api-keys?${queryString}` : "/api-keys";
    const data = await this.resend.get(url);
    return data;
  }
  async remove(id) {
    const data = await this.resend.delete(
      `/api-keys/${id}`
    );
    return data;
  }
};

// src/audiences/audiences.ts
var Audiences = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    const data = await this.resend.post(
      "/audiences",
      payload,
      options
    );
    return data;
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/audiences?${queryString}` : "/audiences";
    const data = await this.resend.get(url);
    return data;
  }
  async get(id) {
    const data = await this.resend.get(
      `/audiences/${id}`
    );
    return data;
  }
  async remove(id) {
    const data = await this.resend.delete(
      `/audiences/${id}`
    );
    return data;
  }
};

// src/common/utils/parse-email-to-api-options.ts
function parseAttachments(attachments) {
  return attachments == null ? void 0 : attachments.map((attachment) => ({
    content: attachment.content,
    filename: attachment.filename,
    path: attachment.path,
    content_type: attachment.contentType,
    content_id: attachment.contentId
  }));
}
function parseEmailToApiOptions(email) {
  return {
    attachments: parseAttachments(email.attachments),
    bcc: email.bcc,
    cc: email.cc,
    from: email.from,
    headers: email.headers,
    html: email.html,
    reply_to: email.replyTo,
    scheduled_at: email.scheduledAt,
    subject: email.subject,
    tags: email.tags,
    text: email.text,
    to: email.to
  };
}

// src/render.ts
async function render(node) {
  let render2;
  try {
    ({ render: render2 } = await import("@react-email/render"));
  } catch (e) {
    throw new Error(
      "Failed to render React component. Make sure to install `@react-email/render` or `@react-email/components`."
    );
  }
  return render2(node);
}

// src/batch/batch.ts
var Batch = class {
  constructor(resend) {
    this.resend = resend;
  }
  async send(payload, options) {
    return this.create(payload, options);
  }
  async create(payload, options) {
    var _a;
    const emails = [];
    for (const email of payload) {
      if (email.react) {
        email.html = await render(email.react);
        email.react = void 0;
      }
      emails.push(parseEmailToApiOptions(email));
    }
    const data = await this.resend.post(
      "/emails/batch",
      emails,
      __spreadProps(__spreadValues({}, options), {
        headers: __spreadValues({
          "x-batch-validation": (_a = options == null ? void 0 : options.batchValidation) != null ? _a : "strict"
        }, options == null ? void 0 : options.headers)
      })
    );
    return data;
  }
};

// src/broadcasts/broadcasts.ts
var Broadcasts = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    if (payload.react) {
      payload.html = await render(payload.react);
    }
    const data = await this.resend.post(
      "/broadcasts",
      {
        name: payload.name,
        audience_id: payload.audienceId,
        preview_text: payload.previewText,
        from: payload.from,
        html: payload.html,
        reply_to: payload.replyTo,
        subject: payload.subject,
        text: payload.text
      },
      options
    );
    return data;
  }
  async send(id, payload) {
    const data = await this.resend.post(
      `/broadcasts/${id}/send`,
      { scheduled_at: payload == null ? void 0 : payload.scheduledAt }
    );
    return data;
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/broadcasts?${queryString}` : "/broadcasts";
    const data = await this.resend.get(url);
    return data;
  }
  async get(id) {
    const data = await this.resend.get(
      `/broadcasts/${id}`
    );
    return data;
  }
  async remove(id) {
    const data = await this.resend.delete(
      `/broadcasts/${id}`
    );
    return data;
  }
  async update(id, payload) {
    if (payload.react) {
      payload.html = await render(payload.react);
    }
    const data = await this.resend.patch(
      `/broadcasts/${id}`,
      {
        name: payload.name,
        audience_id: payload.audienceId,
        from: payload.from,
        html: payload.html,
        text: payload.text,
        subject: payload.subject,
        reply_to: payload.replyTo,
        preview_text: payload.previewText
      }
    );
    return data;
  }
};

// src/contacts/contacts.ts
var Contacts = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    const data = await this.resend.post(
      `/audiences/${payload.audienceId}/contacts`,
      {
        unsubscribed: payload.unsubscribed,
        email: payload.email,
        first_name: payload.firstName,
        last_name: payload.lastName
      },
      options
    );
    return data;
  }
  async list(options) {
    const _a = options, { audienceId } = _a, paginationOptions = __objRest(_a, ["audienceId"]);
    const queryString = buildPaginationQuery(paginationOptions);
    const url = queryString ? `/audiences/${audienceId}/contacts?${queryString}` : `/audiences/${audienceId}/contacts`;
    const data = await this.resend.get(url);
    return data;
  }
  async get(options) {
    if (!options.id && !options.email) {
      return {
        data: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    }
    const data = await this.resend.get(
      `/audiences/${options.audienceId}/contacts/${(options == null ? void 0 : options.email) ? options == null ? void 0 : options.email : options == null ? void 0 : options.id}`
    );
    return data;
  }
  async update(options) {
    if (!options.id && !options.email) {
      return {
        data: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    }
    const data = await this.resend.patch(
      `/audiences/${options.audienceId}/contacts/${(options == null ? void 0 : options.email) ? options == null ? void 0 : options.email : options == null ? void 0 : options.id}`,
      {
        unsubscribed: options.unsubscribed,
        first_name: options.firstName,
        last_name: options.lastName
      }
    );
    return data;
  }
  async remove(payload) {
    if (!payload.id && !payload.email) {
      return {
        data: null,
        error: {
          message: "Missing `id` or `email` field.",
          statusCode: null,
          name: "missing_required_field"
        }
      };
    }
    const data = await this.resend.delete(
      `/audiences/${payload.audienceId}/contacts/${(payload == null ? void 0 : payload.email) ? payload == null ? void 0 : payload.email : payload == null ? void 0 : payload.id}`
    );
    return data;
  }
};

// src/common/utils/parse-domain-to-api-options.ts
function parseDomainToApiOptions(domain) {
  return {
    name: domain.name,
    region: domain.region,
    custom_return_path: domain.customReturnPath
  };
}

// src/domains/domains.ts
var Domains = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    const data = await this.resend.post(
      "/domains",
      parseDomainToApiOptions(payload),
      options
    );
    return data;
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/domains?${queryString}` : "/domains";
    const data = await this.resend.get(url);
    return data;
  }
  async get(id) {
    const data = await this.resend.get(
      `/domains/${id}`
    );
    return data;
  }
  async update(payload) {
    const data = await this.resend.patch(
      `/domains/${payload.id}`,
      {
        click_tracking: payload.clickTracking,
        open_tracking: payload.openTracking,
        tls: payload.tls
      }
    );
    return data;
  }
  async remove(id) {
    const data = await this.resend.delete(
      `/domains/${id}`
    );
    return data;
  }
  async verify(id) {
    const data = await this.resend.post(
      `/domains/${id}/verify`
    );
    return data;
  }
};

// src/emails/emails.ts
var Emails = class {
  constructor(resend) {
    this.resend = resend;
  }
  async send(payload, options = {}) {
    return this.create(payload, options);
  }
  async create(payload, options = {}) {
    if (payload.react) {
      payload.html = await render(payload.react);
    }
    const data = await this.resend.post(
      "/emails",
      parseEmailToApiOptions(payload),
      options
    );
    return data;
  }
  async get(id) {
    const data = await this.resend.get(
      `/emails/${id}`
    );
    return data;
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails?${queryString}` : "/emails";
    const data = await this.resend.get(url);
    return data;
  }
  async update(payload) {
    const data = await this.resend.patch(
      `/emails/${payload.id}`,
      {
        scheduled_at: payload.scheduledAt
      }
    );
    return data;
  }
  async cancel(id) {
    const data = await this.resend.post(
      `/emails/${id}/cancel`
    );
    return data;
  }
};

// src/webhooks/webhooks.ts
var import_svix = require("svix");
var Webhooks = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    const data = await this.resend.post(
      "/webhooks",
      payload,
      options
    );
    return data;
  }
  async get(id) {
    const data = await this.resend.get(
      `/webhooks/${id}`
    );
    return data;
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/webhooks?${queryString}` : "/webhooks";
    const data = await this.resend.get(url);
    return data;
  }
  async update(id, payload) {
    const data = await this.resend.patch(
      `/webhooks/${id}`,
      payload
    );
    return data;
  }
  async remove(id) {
    const data = await this.resend.delete(
      `/webhooks/${id}`
    );
    return data;
  }
  verify(payload) {
    const webhook = new import_svix.Webhook(payload.webhookSecret);
    return webhook.verify(payload.payload, {
      "svix-id": payload.headers.id,
      "svix-timestamp": payload.headers.timestamp,
      "svix-signature": payload.headers.signature
    });
  }
};

// src/resend.ts
var defaultBaseUrl = "https://api.resend.com";
var defaultUserAgent = `resend-node:${version}`;
var baseUrl = typeof process !== "undefined" && process.env ? process.env.RESEND_BASE_URL || defaultBaseUrl : defaultBaseUrl;
var userAgent = typeof process !== "undefined" && process.env ? process.env.RESEND_USER_AGENT || defaultUserAgent : defaultUserAgent;
var Resend = class {
  constructor(key) {
    this.key = key;
    this.apiKeys = new ApiKeys(this);
    this.audiences = new Audiences(this);
    this.batch = new Batch(this);
    this.broadcasts = new Broadcasts(this);
    this.contacts = new Contacts(this);
    this.domains = new Domains(this);
    this.emails = new Emails(this);
    this.webhooks = new Webhooks(this);
    if (!key) {
      if (typeof process !== "undefined" && process.env) {
        this.key = process.env.RESEND_API_KEY;
      }
      if (!this.key) {
        throw new Error(
          'Missing API key. Pass it to the constructor `new Resend("re_123")`'
        );
      }
    }
    this.headers = new Headers({
      Authorization: `Bearer ${this.key}`,
      "User-Agent": userAgent,
      "Content-Type": "application/json"
    });
  }
  async fetchRequest(path, options = {}) {
    try {
      const response = await fetch(`${baseUrl}${path}`, options);
      if (!response.ok) {
        try {
          const rawError = await response.text();
          return { data: null, error: JSON.parse(rawError) };
        } catch (err) {
          if (err instanceof SyntaxError) {
            return {
              data: null,
              error: {
                name: "application_error",
                statusCode: response.status,
                message: "Internal server error. We are unable to process your request right now, please try again later."
              }
            };
          }
          const error = {
            message: response.statusText,
            statusCode: response.status,
            name: "application_error"
          };
          if (err instanceof Error) {
            return { data: null, error: __spreadProps(__spreadValues({}, error), { message: err.message }) };
          }
          return { data: null, error };
        }
      }
      const data = await response.json();
      return { data, error: null };
    } catch (e) {
      return {
        data: null,
        error: {
          name: "application_error",
          statusCode: null,
          message: "Unable to fetch data. The request could not be resolved."
        }
      };
    }
  }
  async post(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers) {
      for (const [key, value] of new Headers(options.headers).entries()) {
        headers.set(key, value);
      }
    }
    if (options.idempotencyKey) {
      headers.set("Idempotency-Key", options.idempotencyKey);
    }
    const requestOptions = __spreadProps(__spreadValues({
      method: "POST",
      body: JSON.stringify(entity)
    }, options), {
      headers
    });
    return this.fetchRequest(path, requestOptions);
  }
  async get(path, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers) {
      for (const [key, value] of new Headers(options.headers).entries()) {
        headers.set(key, value);
      }
    }
    const requestOptions = __spreadProps(__spreadValues({
      method: "GET"
    }, options), {
      headers
    });
    return this.fetchRequest(path, requestOptions);
  }
  async put(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers) {
      for (const [key, value] of new Headers(options.headers).entries()) {
        headers.set(key, value);
      }
    }
    const requestOptions = __spreadProps(__spreadValues({
      method: "PUT",
      body: JSON.stringify(entity)
    }, options), {
      headers
    });
    return this.fetchRequest(path, requestOptions);
  }
  async patch(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers) {
      for (const [key, value] of new Headers(options.headers).entries()) {
        headers.set(key, value);
      }
    }
    const requestOptions = __spreadProps(__spreadValues({
      method: "PATCH",
      body: JSON.stringify(entity)
    }, options), {
      headers
    });
    return this.fetchRequest(path, requestOptions);
  }
  async delete(path, query) {
    const requestOptions = {
      method: "DELETE",
      body: JSON.stringify(query),
      headers: this.headers
    };
    return this.fetchRequest(path, requestOptions);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Resend
});
